<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My LeetCode Hards</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    pre {
      white-space: pre;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.65rem; /* Smaller text */
      line-height: 1.2;
      color: #d8d8ff; /* Light blue-purple text */
      overflow-x: auto;
    }
    .code-block {
      background-color: #1e1e2e; /* Dark blue-purple background */
      border-radius: 0.375rem;
      padding: 1rem;
    }
    /* Pastel blue and purple syntax highlighting */
    .keyword { color: #c4a7e7; } /* Pastel purple */
    .type { color: #a4b9ef; } /* Pastel blue */
    .function { color: #7dc4e4; } /* Light blue */
    .variable { color: #b4befe; } /* Lavender */
    .number { color: #f5c2e7; } /* Pink-purple */
    .string { color: #a6e3a1; } /* Pastel green */
    .comment { color: #9399b2; } /* Muted gray-purple */
    .operator { color: #89dceb; } /* Pastel cyan */
    .punctuation { color: #bac2de; } /* Light gray-blue */
  </style>
</head>
<body class="bg-gray-950 text-gray-100">
  <div id="app">
    <header class="bg-gray-800 shadow-sm sticky top-0 z-10">
      <div class="container mx-auto p-4 flex justify-between items-center">
        <div class="flex items-center">
          <svg class="h-6 w-6 text-blue-400 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 18l6-6-6-6"></path>
            <path d="M8 6l-6 6 6 6"></path>
            <path d="M12 2l4 20"></path>
          </svg>
          <h1 class="text-xl font-bold text-gray-200 flex items-center">
            My LeetCode 
            <span class="ml-2 bg-gray-800 text-red-400 text-sm font-medium px-2.5 py-0.5 rounded-full border border-gray-700">
              Hards
            </span>
          </h1>
        </div>
        <nav class="flex items-center space-x-4">
          <button class="text-sm font-medium text-gray-400 hover:text-blue-400">About</button>
          <button class="text-sm font-medium text-gray-400 hover:text-blue-400">Contact</button>
          <a href="https://github.com" target="_blank" class="text-gray-400 hover:text-gray-200">
            <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
          </a>
        </nav>
      </div>
    </header>
    
    <main class="py-8">
      <div class="container mx-auto p-6">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" id="problem-container">
          <!-- Problems will be added here by JavaScript -->
        </div>
      </div>
    </main>
    
    <footer class="bg-gray-800 border-t border-gray-700 py-6">
      <div class="container mx-auto px-4">
        <div class="flex flex-col md:flex-row justify-between items-center">
          <p class="text-sm text-gray-400">
            Â© 2024 My LeetCode Hards. All rights reserved.
          </p>
          <div class="flex space-x-4 mt-4 md:mt-0">
            <a href="#" class="text-gray-400 hover:text-gray-300">
              <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
              </svg>
            </a>
            <a href="#" class="text-gray-400 hover:text-gray-300">
              <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
              </svg>
            </a>
          </div>
        </div>
      </div>
    </footer>
  </div>

  <script>
    // LeetCode problems data - raw, unmodified code from files
    const problems = [
      {
        id: 1,
        number: "352",
        title: "Data Stream as Disjoint Intervals",
        code: `class SummaryRanges {
public:

    unordered_map<int, int> intervalMap;
    vector<int> values;

    SummaryRanges() {
        
    }
    
    void addNum(int value) {

        value++;

        if (!intervalMap[value]) {

        values.push_back(value);

        if (intervalMap[value - 1] && intervalMap[value + 1]) {
            intervalMap[value - 1] = intervalMap[value + 1];
        } else if (intervalMap[value + 1]) {
            intervalMap[value] = intervalMap[value + 1];
        } else if (intervalMap[value - 1]) {
            intervalMap[value] = value;
            intervalMap[value - 1] = intervalMap[value];
        } else {
            intervalMap[value] = value;
        }

        }
        
    }
    
    vector<vector<int>> getIntervals() {

        sort(values.begin(), values.end());
        vector<vector<int>> intervals;

        unordered_map<int, int> endpoints;

        for (int i = 0; i < values.size(); i++) {

            int endpoint = values[i];
            while (intervalMap[endpoint] != endpoint) {
                endpoint = intervalMap[endpoint];
            }

            if (!endpoints[endpoint] && intervalMap[values[i]]) {
                vector<int> interval;
                interval.push_back(values[i] - 1);
                interval.push_back(endpoint - 1);
                intervals.push_back(interval);
            }

            endpoints[endpoint]++;

        }

        return intervals;
        
    }
};

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges* obj = new SummaryRanges();
 * obj->addNum(value);
 * vector<vector<int>> param_2 = obj->getIntervals();
 */`,
        blog: "This solution uses a disjoint-set (union-find) approach to efficiently track intervals as they form. Each value maps to its interval endpoint, allowing constant-time merging of adjacent intervals. The time complexity is dominated by the sorting operation in getIntervals(), making it O(n log n) where n is the number of unique values added."
      },
      {
        id: 2,
        number: "68",
        title: "Text Justification",
        code: `class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {

        vector<string> solution;

        int wordIndex = 0;
        while (wordIndex < words.size()) {

            string tempLine = "";
            int lineSize = 0;
            int charCount = 0;
            int wordCount = 0;

            while ((wordIndex < words.size()) &&
                   (lineSize + words[wordIndex].size() <= maxWidth)) {
                charCount += words[wordIndex].size();
                lineSize += words[wordIndex].size() + 1;
                wordIndex++;
                wordCount++;
            }

            int spaceCount = maxWidth - charCount;

            int spaceAvg = spaceCount;
            int spaceRem = 0;

            if (wordCount > 1) {
                spaceAvg = spaceCount / (wordCount - 1);
                spaceRem = spaceCount % (wordCount - 1);
            }

            if (wordIndex == words.size()) {

                for (int i = wordIndex - wordCount; i < wordIndex; i++) {
                    tempLine += words[i];
                    if (spaceCount > 0) {
                        spaceCount--;
                        tempLine += " ";
                    }
                }
                for (int i = 0; i < spaceCount; i++) {
                    tempLine += " ";
                }

            } else if (wordCount == 1) {

                tempLine += words[wordIndex - 1];
                for (int i = 0; i < spaceCount; i++) {
                    tempLine += " ";
                }

            } else {

                for (int i = wordIndex - wordCount; i < wordIndex; i++) {

                    if (i < wordIndex - 1) {
                        tempLine += words[i];
                        for (int n = 0; n < spaceAvg; n++) {
                            tempLine += " ";
                        }
                        if (spaceRem > 0) {
                            tempLine += " ";
                            spaceRem--;
                        }
                    } else {
                        tempLine += words[i];
                    }
                }
            }

            solution.push_back(tempLine);
        }

        return solution;
        
    }
};`,
        blog: "Text justification requires careful management of spaces between words. The approach involves greedy line filling, calculating even distribution of spaces, with special handling for the last line (left-justified) and lines with a single word. The algorithm has O(n) time complexity where n is the total number of characters across all words."
      },
      {
        id: 3,
        number: "135",
        title: "Candy",
        code: `class Solution {
public:

    int candy(vector<int>& ratings) {

        unordered_map<int, int> indexValues;
        vector<int> greedyVector;

        int height = 1;
        indexValues[0] = 1;
        for (int i = 1; i < ratings.size(); i++) { 

            if (ratings[i] > ratings[i - 1]) {
                height++;
            } else {
                height = 1;
            }

            indexValues[i] = height;

        }

        height = 1;
        int totalCandies = indexValues[ratings.size() - 1];

        for (int i = ratings.size() - 2; i >= 0; i--) { 

            if (ratings[i] > ratings[i + 1]) {
                height++;
            } else {
                height = 1;
            }

            totalCandies += max(indexValues[i], height);

        }

        return totalCandies;

    }

};`,
        blog: "This solution uses a two-pass approach to ensure that each child with a higher rating gets more candies than their neighbors. The first pass assigns candies based on left-to-right comparisons, and the second pass adjusts for right-to-left comparisons, taking the maximum value needed to satisfy both constraints. The algorithm achieves an optimal O(n) time complexity."
      },
      {
        id: 4,
        number: "149",
        title: "Max Points on a Line",
        code: `class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {

        if (points.size() == 1) return 1;

        int maxPoints = 0;
        unordered_map<int, int> vert;
        for (int i = 0; i < points.size(); i++) {
            vert[points[i][0]]++;
            numMax = max(numMax, vert[points[i][0]]);
        }

        for (int i = 0; i < points.size() - 1; i++) {

            unordered_map<double, int> seen;

            int y1 = points[i][1];
            int x1 = points[i][0];
            for (int n = i + 1; n < points.size(); n++) {

                int y2 = points[n][1];
                int x2 = points[n][0];
                int dy = (y2 - y1);
                int dx = (x2 - x1);

                if (dx != 0) {
                    double slope = (dy + 0.0) / (dx + 0.0);
                    seen[slope]++;
                    numMax = max(numMax, (seen[slope] + 1));
                } 
                
            }

        }

        return maxPoints;

    }
};`,
        blog: "Finding the maximum number of points on a line requires checking all possible lines. This solution first handles vertical lines separately, then computes slopes between each pair of points to count collinear points. By storing slope frequencies in a hash map, we achieve O(nÂ²) time complexity, which is optimal for this problem as we must check all pairs of points."
      },
      {
        id: 5,
        number: "1028",
        title: "Recover a Tree From Preorder Traversal",
        code: `/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    TreeNode* recoverFromPreorder(string traversal) {
        
        traversal += '-';
        unordered_map<int, TreeNode*> depthLastNode;

        string stringVal = "";
        int index = 0;
        while (traversal[index] != '-') {
            stringVal += traversal[index];
            index++;
        }

        int startVal = stoi(stringVal);

        TreeNode* root = new TreeNode(startVal);
        depthLastNode[0] = root;

        int depth = 0;
        for (int i = index; i < traversal.size(); i++) {

            if (traversal[i] == '-') {
                depth++;
            } else {

                stringVal = "";
                while (traversal[i] != '-') {
                    stringVal += traversal[i];
                    i++;
                }

                i--;

                int currVal = stoi(stringVal);
                TreeNode* currNode = new TreeNode(currVal);
                depthLastNode[depth] = currNode;
                
                TreeNode* parent = depthLastNode[depth - 1];
                if (!parent->left) {
                    parent->left = currNode;
                } else {
                    parent->right = currNode;
                }

                depth = 0;

            }

        }

        return root;

    }

};`,
        blog: "This problem requires parsing a string representation of a binary tree's preorder traversal with depth information. The key insight is using a map to track the last node seen at each depth level, which serves as the parent for the next node at a deeper level. This single-pass approach achieves O(n) time complexity, where n is the length of the input string."
      },
      {
        id: 6,
        number: "980",
        title: "Unique Paths III",
        code: `class Solution {
public:

    int m;
    int n;
    vector<vector<bool>> visited;
    vector<vector<int>> mainGrid;
    int total;

    int uniquePathsIII(vector<vector<int>>& grid) {

        int startRow = 0;
        int startCol = 0;
        int steps = 0;

        m = grid[0].size();
        n = grid.size();
        total = 0;
        mainGrid = grid;

        for (int r = 0; r < n; r++) {
            vector<bool> temp;
            for (int c = 0; c < m; c++) {
                temp.push_back(false);
                if (grid[r][c] == 1) {
                    startRow = r;
                    startCol = c;
                }
                if (grid[r][c] >= 0) steps++;
            }
            visited.push_back(temp);
        }

        backtracking(startRow, startCol, steps);

        return total;
        
    }

    void backtracking(int r, int c, int steps) {

        if (r < 0 || r >= n || c < 0 || c >= m || visited[r][c] || mainGrid[r][c] == -1) return;
        if (mainGrid[r][c] == 2 && steps == 1) total++;

        visited[r][c] = true;
        steps--;

        backtracking(r + 1, c, steps);
        backtracking(r - 1, c, steps);
        backtracking(r, c + 1, steps);
        backtracking(r, c - 1, steps);

        visited[r][c] = false;

    }
};`,
        blog: "This solution uses backtracking to find all possible paths that visit every empty cell exactly once. The key insight is tracking both visited cells with a boolean matrix and remaining steps to ensure we've visited all empty cells. Time complexity is O(3^(N*M)) as we have at most 3 directions to explore at each step (can't go back to the previous cell)."
      }
    ];

    // Function to add pastel blue/purple syntax highlighting to code
    function applyPastelSyntaxHighlighting(code) {
      // Escape HTML entities first
      const escapedCode = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Apply pastel blue/purple syntax highlighting
      return escapedCode
        .replace(/\b(class|public|private|protected|void|int|double|string|vector|unordered_map|if|else|for|while|return|new|nullptr|struct)\b/g, '<span style="color:#c4a7e7">$1</span>') // keywords - pastel purple
        .replace(/\b(TreeNode|Solution|SummaryRanges)\b/g, '<span style="color:#a4b9ef">$1</span>') // types - pastel blue
        .replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*(?=\()/g, '<span style="color:#7dc4e4">$1</span>') // functions - light blue
        .replace(/\/\/(.*)/g, '<span style="color:#9399b2">//$1</span>') // comments - muted gray-purple
        .replace(/\b([0-9]+)\b/g, '<span style="color:#f5c2e7">$1</span>') // numbers - pink-purple
        .replace(/(\+|\-|\*|\/|=|==|!=|&lt;|&gt;|&amp;&amp;|\|\||\!|\?|\:)/g, '<span style="color:#89dceb">$1</span>') // operators - pastel cyan
        .replace(/(\{|\}|\(|\)|\[|\]|;|,|\.)/g, '<span style="color:#bac2de">$1</span>'); // punctuation - light gray-blue
    }

    // Render problems with better syntax highlighting
    function renderProblems() {
      const container = document.getElementById('problem-container');
      
      problems.forEach(problem => {
        // Create card element
        const card = document.createElement('div');
        card.className = 'bg-gray-800 rounded-lg shadow-md overflow-hidden transition-transform duration-300 hover:shadow-lg hover:scale-105 cursor-pointer border border-gray-700';
        
        // Card header
        const header = document.createElement('div');
        header.className = 'p-4 border-b border-gray-700 bg-gray-900 flex justify-between items-center';
        header.innerHTML = `
          <h3 class="text-lg font-semibold text-gray-200">
            ${problem.number}. ${problem.title}
          </h3>
          <span class="bg-gray-800 text-red-400 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full border border-gray-700">
            Hard
          </span>
        `;
        
        // Card body
        const body = document.createElement('div');
        body.className = 'p-4';
        
        // Code section with pastel blue/purple syntax highlighting
        const codeBlock = document.createElement('div');
        codeBlock.className = 'code-block overflow-hidden h-64';
        
        const preElement = document.createElement('pre');
        preElement.className = 'overflow-auto h-full';
        preElement.innerHTML = applyPastelSyntaxHighlighting(problem.code);
        
        codeBlock.appendChild(preElement);
        
        // Blog preview
        const blogPreview = document.createElement('p');
        blogPreview.className = 'mt-4 text-sm text-gray-400';
        blogPreview.textContent = `${problem.blog.substring(0, 150)}...`;
        
        body.appendChild(codeBlock);
        body.appendChild(blogPreview);
        
        // Card footer
        const footer = document.createElement('div');
        footer.className = 'p-4 bg-gray-900 flex justify-end';
        footer.innerHTML = `
          <button class="text-blue-400 flex items-center text-sm font-medium">
            View solution 
            <svg class="ml-1 h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M5 12h14"></path>
              <path d="M12 5l7 7-7 7"></path>
            </svg>
          </button>
        `;
        
        // Append all sections to card
        card.appendChild(header);
        card.appendChild(body);
        card.appendChild(footer);
        
        // Add card to container
        container.appendChild(card);
      });
    }
    
    // Initialize the page
    renderProblems();
  </script>
</body>
</html>
